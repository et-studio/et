### 2015-4-21 第一个很难解决的难题

说到第一个难题，要首先说一下ET的核心概念。
首先是最基本的理念：在模板里面控制dom的生命周期，同一个模板实例从创建出来到死亡掉，其内部的dom也应该共同生死。
换句话说，在初始化或者更新（update函数）的时候产生dom，而在摧毁（destroy函数）的时候dom相应remove掉。
模板控制dom的生命周期的好处在于：
1.更新的时候能够进行持续的状态切换，连续动画的实现。
2.dom局部数据的更新，性能更加好了。

基于前面的核心理念，然后有了最初的ET的想法，那就是在初始化的时候生成一个$root对象，来保存整个dom树，然后其下的所有子节点都从这个dom树进行获取或者在update的时候会按需产生新的dom。
问题就在于dom树的根节点与新生节点的问题。
由于实际使用的时候一般不会只有一个根节点，可能会有初始化的dom就由很多根节点的情况，并且会有可能新生的节点也是根节点。那么问题来了，如果能够动态产生根节点，那么一开始产生的那个$root对象就无法保证完整性。

解释可能无法阐释清楚，那么就来一段代码。
```
<div>1</div>
[#if it.isTrue]
<div>2</div>
[/#if]
<div>3</div>
```
这段代码按照前面的思维模式会形成下面的问题。
初始化模板：
```
$root ->  $('<div>1</div><div class="et-line"></div><div>3</div>')
```
这个时候 div2 还没有被产生出来，那么调用update函数会在页面的div.et-line后面插入div2。
但是此时的$root对象仍然没有变化，因为$root对象已经经过了其他很多的行为了，比如事件委托，而新的div2本来也是根节点，需要进行事件委托（虽然这个事件委托很好做）。关键问题按照前面的节点生命周期的理念，这里是很难进行$root对象的更新行为。

核心问题，在保证dom生命周期的情况下，将dom对象更新掉。这要研究一下jQuery的代码，看看其核心的实现方式。
查看了jQuery的append方法，每次进行append的时候对html而言都会进行一次移除和产生的重绘，不能达到期望的效果。（这个问题会对dom数组有很大的影响，因为每次进行重绘的时候都需要进行数组的重新查询和排序，会进行dom的重排。）

首先不考虑dom生命周期的问题，我就当是使用add函数能够进行生命周期的控制，但是问题是每次进行update的时候整个for循环都需要重新插入一遍。
此时问题转变成为，每次进行update的时候如果保证最低耗的for循环绘制。


### 2015-04-23 感谢龙兄，新的体会

前面说到了ET遇见了第一个关乎底层模板设计的问题，然后这两天跟龙兄交流了一下技术，发现自己懂的东西真得是太少了，外加上最近状态也不是那么好，感觉好消极，总想要做点什么，渴望别人的认可。我想把ET模板完成掉。

首先理清思路，模板的核心理念是模板关联dom生命周期，目的是提高模板运行效率。
说到这个目的，想来前面的想法以及核心理念都不一定能达到这个目的，所以我现在要进行一次反思。

我在模板中管理dom的生命周期其实是管理dom对象，现在知道的是能够管理事件，即ET对象存在的时候，dom对象也存在（不一定在页面中），并且事件一直在。但是跟龙兄交流了之后我发现，现在影响页面模板性能的不一定是dom对象的生命周期，而是页面中dom的绘制，也就是说，如果合并成String之后整个插入页面中和dom分散插入dom中性能差距非常大。因为每一次的dom插入都会引起那一部分的重绘，那一部分节点查找样式表。而如果使用了fragment整体插入能带来很大的性能提升。

但是，如果dom已经插入到页面中了，那么再使用String拼装插入这样是不合适的，因为这样会进行dom的杀死和新生，也就是说真正的生命周期的管理不应该是在js内存中的管理，而是在页面中的dom的管理。也就是说，如果模板中的dom已经插入了页面内，那么使用差异更新的方式会比较快，因为这时是对一个node对象的属性修改，不涉及到对象的变化。

综上所述，核心理念不变，但是代码逻辑产生变化。整个html的预编译会主要生成两个东西，初始化代码和update函数代码，主要变化的是基础的get函数和ET对象本身，本身不再具备基础的$root对象，根节点对象都保存在roots这个数组中，在get的时候统一组装成为一个fragment对象返回。

另外一些疑问，使用原生对象操作会不会比较快一点？使用对象树进行操作会不会比较快一点？
初始化的代码逻辑发生变化。最早的时候我是把基础的String全拼装好之后再生成的基础的$root对象，但是昨天在犀牛书上看见说，css的选择器是会遍历符合的dom然后再去掉非祖先的节点，所以我觉得直接把element生成并且拿在手中这样比较好，我怀疑jQuery也是一个一个生成的吗？这点其实待确认。


### 2015-05-02 开始在git上面编程了

在github上面开了项目，然后跟龙兄一起写代码。

### 2015-05-03 梳理了一下项目结构

* doc     文档说明
* example 常用例子
* gulp    开发时编译任务
* public  es5可使用的资源文件
* src     es6开发时资源文件
* test    测试资源

###2015-05-04
>
commit by Brooklyn
>
初始化了parser.js，用于将HTML字符串编译成为一个树形的对象，其中包含用ECMAScript DOM API 创建的Node节点实例。
初步的想法是使用一个自动机(Auto Machine)和一个有限状态机(State Machine)来将整个字符串Parser成树。其中流程如下：
>
* Parser的main function扫描字符串，产生token传入状态机
* 状态机将token与终结符号表对比，产生一个**编译时状态**(parsing state)，并将其输入自动机
* 自动机根据编译时状态产生一个新的**编译前状态**(pre parser state)返回给状态机
* 状态机根据这个**编译前状态**(pre parser state)去找到相应的工具方法，并将token传给工具方法处理，这个**编译前状态**(pre parser state)会一直保存作为下次状态机产生新的编译时状态(parsing state)的依据
* 主程序循环第一步直到字符串扫描完毕



